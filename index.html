<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doodle Sound App</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f3f4f6; /* Tailwind bg-gray-100 */
        }
        #app-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff; /* Tailwind bg-white */
            padding: 2rem; /* Tailwind p-8 */
            border-radius: 0.75rem; /* Tailwind rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Tailwind shadow-lg */
            width: 90%;
            max-width: 400px;
        }
        #color-brushes {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.75rem; /* Tailwind gap-3 */
            margin-bottom: 1rem; /* Tailwind mb-4 */
        }
        .color-brush {
            width: 35px; /* 増加 */
            height: 35px; /* 増加 */
            border-radius: 9999px; /* Tailwind rounded-full */
            cursor: pointer;
            border: 3px solid #d1d5db; /* Tailwind border-gray-300, border-2 から border-3 へ */
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
        }
        .color-brush:hover {
            transform: scale(1.1);
            box-shadow: 0 0 8px rgba(0,0,0,0.2);
        }
        .color-brush.active {
            border-color: #1f2937; /* Tailwind border-gray-800 */
            box-shadow: 0 0 10px rgba(31, 41, 55, 0.5); /* Tailwind shadow-md, 色調整 */
        }
        #doodle-canvas {
            width: 100%;
            height: 250px; /* 高さを少し増加 */
            border: 2px solid #4b5563; /* Tailwind border-gray-600 */
            background-color: #ffffff; /* Tailwind bg-white */
            cursor: crosshair;
            margin-bottom: 1rem; /* Tailwind mb-4 */
            border-radius: 0.5rem; /* Tailwind rounded-lg */
            touch-action: none; /* ピンチズームなどを防ぐ */
        }
        #sound-button {
            padding: 0.75rem 1.5rem; /* Tailwind py-3 px-6 */
            font-size: 1rem; /* Tailwind text-base */
            font-weight: 600; /* Tailwind font-semibold */
            color: #ffffff; /* Tailwind text-white */
            background-color: #3b82f6; /* Tailwind bg-blue-500 */
            border: none;
            border-radius: 0.5rem; /* Tailwind rounded-lg */
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            width: 100%;
        }
        #sound-button:hover {
            background-color: #2563eb; /* Tailwind bg-blue-600 */
            transform: translateY(-1px);
        }
        #sound-button:active {
            transform: translateY(0px);
        }
        #sound-button:disabled {
            background-color: #9ca3af; /* Tailwind bg-gray-400 */
            cursor: not-allowed;
        }
        /* メッセージ表示用のスタイル */
        #message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #1f2937; /* Tailwind bg-gray-800 */
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none; /* 初期状態では非表示 */
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="color-brushes">
            </div>
        <canvas id="doodle-canvas"></canvas>
        <button id="sound-button">絵を音に変換</button>
    </div>
    <div id="message-box"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('doodle-canvas');
            const ctx = canvas.getContext('2d');
            const colorBrushesContainer = document.getElementById('color-brushes');
            const soundButton = document.getElementById('sound-button');
            const messageBox = document.getElementById('message-box');

            // キャンバスの解像度を設定 (Retinaディスプレイ対応)
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            // CSSで設定されたサイズで描画するように調整
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;


            let drawing = false;
            let currentColor = '#000000'; // 初期色: 黒
            let currentLineWidth = 5;

            // 利用可能な色 (画像に合わせて8色)
            const colors = [
                '#EF4444', '#22C55E', '#3B82F6', '#EAB308', // 赤, 緑, 青, 黄 (Tailwind colors)
                '#EC4899', '#06B6D4', '#F97316', '#6B7280'  // マゼンタ系, シアン系, オレンジ系, グレー (Tailwind colors)
            ];

            // カラーブラシを生成
            colors.forEach(color => {
                const brush = document.createElement('div');
                brush.classList.add('color-brush');
                brush.style.backgroundColor = color;
                brush.dataset.color = color;
                if (color === currentColor) {
                    brush.classList.add('active');
                }
                brush.addEventListener('click', () => {
                    currentColor = brush.dataset.color;
                    document.querySelectorAll('.color-brush').forEach(b => b.classList.remove('active'));
                    brush.classList.add('active');
                });
                colorBrushesContainer.appendChild(brush);
            });

            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentLineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            function getEventPosition(canvasDom, event) {
                const rect = canvasDom.getBoundingClientRect();
                const scaleX = canvasDom.width / dpr / rect.width;    // 関係 X
                const scaleY = canvasDom.height / dpr / rect.height;  // 関係 Y

                let clientX, clientY;
                if (event.touches && event.touches.length > 0) {
                    clientX = event.touches[0].clientX;
                    clientY = event.touches[0].clientY;
                } else {
                    clientX = event.clientX;
                    clientY = event.clientY;
                }
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }


            function startDrawing(e) {
                drawing = true;
                const pos = getEventPosition(canvas, e);
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                e.preventDefault(); // スクロールなどを防ぐ
            }

            function draw(e) {
                if (!drawing) return;
                const pos = getEventPosition(canvas, e);
                ctx.lineTo(pos.x, pos.y);
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentLineWidth;
                ctx.stroke();
                e.preventDefault();
            }

            function stopDrawing() {
                if (drawing) {
                    ctx.closePath();
                    drawing = false;
                }
            }

            // マウスイベント
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing); // mouseout から mouseleave に変更

            // タッチイベント
            canvas.addEventListener('touchstart', startDrawing, { passive: false });
            canvas.addEventListener('touchmove', draw, { passive: false });
            canvas.addEventListener('touchend', stopDrawing);
            canvas.addEventListener('touchcancel', stopDrawing);

            // AudioContextの初期化
            let audioCtx;
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.error('Web Audio API is not supported in this browser');
                displayMessage('お使いのブラウザは音声再生に対応していません。');
                soundButton.disabled = true;
                soundButton.textContent = '音声未対応';
            }

            function displayMessage(message, duration = 3000) {
                messageBox.textContent = message;
                messageBox.style.display = 'block';
                setTimeout(() => { messageBox.style.opacity = '1'; }, 10); // 表示後にフェードイン

                setTimeout(() => {
                    messageBox.style.opacity = '0';
                    setTimeout(() => { messageBox.style.display = 'none'; }, 500); // フェードアウト後に非表示
                }, duration);
            }

            soundButton.addEventListener('click', () => {
                if (!audioCtx) {
                    displayMessage('音声機能が初期化されていません。');
                    return;
                }
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const { width, height } = canvas; // ここでは解像度調整後のピクセル数
                let time = audioCtx.currentTime;
                const noteDuration = 0.08; // 各音の長さ（秒）を短く
                const attackTime = 0.01;
                const releaseTime = 0.07;

                const notesToPlay = [];
                let hasDrawing = false;

                // スキャンする間隔を調整 (パフォーマンスと精度のため)
                const scanStep = Math.max(1, Math.floor(width / (100 * dpr) )); // 画面幅に応じてステップ調整

                for (let x = 0; x < width; x += scanStep) {
                    let sumY = 0;
                    let count = 0;
                    let rSum = 0, gSum = 0, bSum = 0;

                    for (let y = 0; y < height; y += scanStep) { // Y方向もステップ実行
                        const index = (Math.floor(y) * width + Math.floor(x)) * 4;
                        if (data[index + 3] > 128) { // ある程度不透明なピクセル
                             // 白背景でないことを確認 (R,G,Bが全て250以上ではない)
                            if (data[index] < 250 || data[index+1] < 250 || data[index+2] < 250) {
                                sumY += y;
                                rSum += data[index];
                                gSum += data[index+1];
                                bSum += data[index+2];
                                count++;
                                hasDrawing = true;
                            }
                        }
                    }

                    if (count > 0) {
                        const avgY = sumY / count;
                        const avgR = rSum / count;
                        const avgG = gSum / count;
                        const avgB = bSum / count;

                        // Y座標を周波数にマッピング (高い位置ほど高い音)
                        // 100Hz (低い音) から 1200Hz (高い音) の範囲
                        const frequency = 100 + ((height - avgY) / height) * 1100;

                        // 色相に基づいて音色やフィルターを少し変える (簡易的)
                        // HSLに変換して色相(Hue)を取得
                        const maxC = Math.max(avgR, avgG, avgB);
                        const minC = Math.min(avgR, avgG, avgB);
                        let hue = 0;
                        if (maxC !== minC) {
                            if (maxC === avgR) hue = (avgG - avgB) / (maxC - minC);
                            else if (maxC === avgG) hue = 2 + (avgB - avgR) / (maxC - minC);
                            else hue = 4 + (avgR - avgG) / (maxC - minC);
                            hue *= 60;
                            if (hue < 0) hue += 360;
                        }

                        let waveType = 'triangle';
                        if (hue > 0 && hue <= 120) waveType = 'sawtooth'; // 赤〜緑
                        else if (hue > 120 && hue <= 240) waveType = 'square'; // 緑〜青

                        notesToPlay.push({ frequency, time, waveType });
                        time += noteDuration;
                    }
                }

                if (!hasDrawing) {
                    displayMessage('何も描かれていません。音を鳴らすには何か描いてください。');
                    // デフォルト音を鳴らす (任意)
                    const oscillator = audioCtx.createOscillator();
                    const gainNode = audioCtx.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(220, audioCtx.currentTime); // A3
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.3);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.3);
                    return;
                }
                
                displayMessage('音を再生中...');

                notesToPlay.forEach(note => {
                    const oscillator = audioCtx.createOscillator();
                    const gainNode = audioCtx.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);

                    oscillator.type = note.waveType;
                    oscillator.frequency.setValueAtTime(note.frequency, note.time);
                    
                    // エンベロープ (ADSRの簡易版: Attack, Decay/Sustain, Release)
                    gainNode.gain.setValueAtTime(0, note.time); // スタート時の音量は0
                    gainNode.gain.linearRampToValueAtTime(0.4, note.time + attackTime); // Attack
                    gainNode.gain.linearRampToValueAtTime(0.0001, note.time + noteDuration - releaseTime + releaseTime); // Release

                    oscillator.start(note.time);
                    oscillator.stop(note.time + noteDuration + 0.1); // 少し長めにstopを設定
                });
            });

            // ウィンドウリサイズ時にキャンバスサイズを再調整
            window.addEventListener('resize', () => {
                const currentRect = canvas.getBoundingClientRect();
                canvas.width = currentRect.width * dpr;
                canvas.height = currentRect.height * dpr;
                ctx.scale(dpr, dpr);
                // 描画設定を再適用
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentLineWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                // 必要であれば、リサイズ時にキャンバスの内容を再描画するロジックを追加
                // (現状ではリサイズすると描画内容は消えます)
                displayMessage('ウィンドウがリサイズされました。描画内容はクリアされます。', 2000);
                ctx.clearRect(0,0,canvas.width, canvas.height); // リサイズ時にクリア
            });

        });
    </script>
</body>
</html>
